<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.moralok.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文记录了 Redis 的内存淘汰策略，并介绍了其中 LRU 和 LFU 算法实现相比于普通版本的优化思路，最后简单探究了 Redis 关于内存淘汰的具体实现细节，重点关注 Redis 是如何选取和评估哪些 key 是更应该优先被淘汰的 key。在探究的过程中，再次体会到 Chat GPT 带来的便捷和它在细微之处的胡说八道，以及网上的资料很有帮助但是通过阅读源码加以验证同样重要。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 的内存淘汰">
<meta property="og:url" content="https://www.moralok.com/2024/12/04/memory-eviction-in-Redis/index.html">
<meta property="og:site_name" content="Moralok&#39;s Blog">
<meta property="og:description" content="本文记录了 Redis 的内存淘汰策略，并介绍了其中 LRU 和 LFU 算法实现相比于普通版本的优化思路，最后简单探究了 Redis 关于内存淘汰的具体实现细节，重点关注 Redis 是如何选取和评估哪些 key 是更应该优先被淘汰的 key。在探究的过程中，再次体会到 Chat GPT 带来的便捷和它在细微之处的胡说八道，以及网上的资料很有帮助但是通过阅读源码加以验证同样重要。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-04T07:55:30.000Z">
<meta property="article:modified_time" content="2024-12-27T13:21:07.189Z">
<meta property="article:author" content="Moralok">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="algorithm">
<meta property="article:tag" content="memory eviction">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.moralok.com/2024/12/04/memory-eviction-in-Redis/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.moralok.com/2024/12/04/memory-eviction-in-Redis/","path":"2024/12/04/memory-eviction-in-Redis/","title":"Redis 的内存淘汰"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis 的内存淘汰 | Moralok's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2MBCXKHJL0"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2MBCXKHJL0","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Moralok's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">你在幼年时当快乐</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.</span> <span class="nav-text">Redis 的内存淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E4%BC%98%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">Redis 的内存淘汰优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%BC%BC-LRU"><span class="nav-number">2.1.</span> <span class="nav-text">近似 LRU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%BC%BC-LFU"><span class="nav-number">2.2.</span> <span class="nav-text">近似 LFU</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">3.</span> <span class="nav-text">Redis 的内存淘汰实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#freeMemoryIfNeeded"><span class="nav-number">3.1.</span> <span class="nav-text">freeMemoryIfNeeded</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E5%8F%96%E2%80%9C%E6%9C%80%E4%BD%B3%E2%80%9D%E7%9A%84%E6%B7%98%E6%B1%B0%E7%9B%AE%E6%A0%87-key"><span class="nav-number">3.2.</span> <span class="nav-text">选取“最佳”的淘汰目标 key</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8-Random-%E7%AD%96%E7%95%A5%E6%97%B6%E9%80%89%E6%8B%A9-key"><span class="nav-number">3.2.1.</span> <span class="nav-text">在使用 Random 策略时选择 key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8-LRU%E3%80%81LFU-%E5%92%8C-TTL-%E7%AD%96%E7%95%A5%E6%97%B6%E9%80%89%E6%8B%A9-key"><span class="nav-number">3.2.2.</span> <span class="nav-text">在使用 LRU、LFU 和 TTL 策略时选择 key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A1%AB%E5%85%85-EvictionPoolLRU"><span class="nav-number">3.2.3.</span> <span class="nav-text">填充 EvictionPoolLRU</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0-key"><span class="nav-number">3.3.</span> <span class="nav-text">淘汰 key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E2%80%9C%E6%9B%B4%E5%BA%94%E8%AF%A5%E4%BC%98%E5%85%88%E8%A2%AB%E6%B7%98%E6%B1%B0%E2%80%9D"><span class="nav-number">3.4.</span> <span class="nav-text">如何评估“更应该优先被淘汰”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">3.4.1.</span> <span class="nav-text">Redis 的对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8-LRU-%E7%AD%96%E7%95%A5%E6%97%B6%E7%9A%84%E8%AF%84%E4%BC%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.2.</span> <span class="nav-text">在使用 LRU 策略时的评估机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lruclock-%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9B%B4%E6%96%B0"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">lruclock 的定义和更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E6%97%B6%E9%97%B4%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">空闲时间的计算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8-LFU-%E7%AD%96%E7%95%A5%E6%97%B6%E7%9A%84%E8%AF%84%E4%BC%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.3.</span> <span class="nav-text">在使用 LFU 策略时的评估机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#logc-%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9B%B4%E6%96%B0"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">logc 的定义和更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ldt-%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9B%B4%E6%96%B0"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">ldt 的定义和更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%B8%B8%E8%AE%BF%E9%97%AE%E7%A8%8B%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">不常访问程度的计算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8-TTL-%E7%AD%96%E7%95%A5%E6%97%B6%E7%9A%84%E8%AF%84%E4%BC%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.4.</span> <span class="nav-text">在使用 TTL 策略时的评估机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%92%8C%E6%84%9F%E5%8F%97"><span class="nav-number">4.</span> <span class="nav-text">总结和感受</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Moralok</p>
  <div class="site-description" itemprop="description">却要知道，为这一切的事……</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/moralok" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;moralok" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.moralok.com/2024/12/04/memory-eviction-in-Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Moralok">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moralok's Blog">
      <meta itemprop="description" content="却要知道，为这一切的事……">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis 的内存淘汰 | Moralok's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 的内存淘汰
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 15:55:30" itemprop="dateCreated datePublished" datetime="2024-12-04T15:55:30+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-27 21:21:07" itemprop="dateModified" datetime="2024-12-27T21:21:07+08:00">2024-12-27</time>
    </span>

  
    <span id="/2024/12/04/memory-eviction-in-Redis/" class="post-meta-item leancloud_visitors" data-flag-title="Redis 的内存淘汰" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文记录了 <code>Redis</code> 的<strong>内存淘汰策略</strong>，并介绍了其中 <code>LRU</code> 和 <code>LFU</code> 算法实现相比于普通版本的<strong>优化思路</strong>，最后简单探究了 <code>Redis</code> 关于内存淘汰的<strong>具体实现细节</strong>，重点关注 <code>Redis</code> 是如何<strong>选取</strong>和<strong>评估</strong>哪些 <code>key</code> 是更应该优先被淘汰的 <code>key</code>。<br>在探究的过程中，再次体会到 Chat GPT 带来的便捷和它在细微之处的胡说八道，以及网上的资料很有帮助但是通过阅读源码加以验证同样重要。</p>
<span id="more"></span>

<p>前置补充说明：</p>
<ul>
<li>以下提到的代码文件可在 <a target="_blank" rel="noopener" href="https://github.com/redis/redis/">GitHub 的 redis 代码库</a>中搜索。</li>
<li>引用代码的分支版本为 <code>4.0</code>。</li>
<li>阅读代码并不需要对 <code>C</code> 语言有多深入的了解，也不需要配置相关环境，通过在 <code>Github</code> 代码库中搜索符号跳转即可完成。</li>
</ul>
<h2 id="Redis-的内存淘汰策略"><a href="#Redis-的内存淘汰策略" class="headerlink" title="Redis 的内存淘汰策略"></a>Redis 的内存淘汰策略</h2><p>Redis 的内存淘汰策略可以通过配置项 <code>maxmemory-policy</code> 设置，最大内存阈值可以通过配置项 <code>maxmemory</code> 设置：</p>
<ul>
<li><code>volatile-lru</code>：从设置了过期时间的数据集中挑选最近最少使用的数据进行淘汰。</li>
<li><code>allkeys-lru</code>：从所有数据集中挑选最近最少使用的数据进行淘汰。</li>
<li><code>volatile-lfu</code>：从设置了过期时间的数据集中挑选最近最不经常使用的数据进行淘汰。</li>
<li><code>allkeys-lfu</code>：从所有数据集中挑选最近最不经常使用的数据进行淘汰。</li>
<li><code>volatile-random</code>：从设置了过期时间的数据集中随机挑选数据进行淘汰。</li>
<li><code>allkeys-random</code>：从所有数据集中随机挑选数据进行淘汰。</li>
<li><code>volatile-ttl</code>：从设置了过期时间的数据集中随机最近要过期的数据进行淘汰。</li>
<li><code>noeviction</code>(默认)：不淘汰数据，当内存不足时，新写入操作将报错。</li>
</ul>
<p>根据面向的数据集分为两类，<strong>设置了过期时间的数据集</strong>指 <code>server.db[i].expires</code>，<strong>所有数据集</strong>指 <code>server.db[i].dict</code>。两者都是 <code>dict</code> 类型，在后续的代码分析中，我们会看到 <code>Redis</code> 根据策略是 <code>volatile</code> 还是 <code>allkeys</code> 类型选择引用哪一个 <code>dict</code>。</p>
<p>根据算法类型分为五类，<code>LRU</code>、<code>LFU</code>、<code>Random</code>、<code>TTL</code> 和 <code>NO</code>。</p>
<blockquote>
<p><code>LFU</code> 算法是在 <code>4.0</code> 版本后新增。其实截至目前（2024年），<code>Redis</code> 的版本已经来到了 <code>8.0</code>，接触到 <code>4.0</code> 以前的版本的可能性已经很低了。</p>
</blockquote>
<p>关于内存淘汰策略的最新定义可以在 <code>config.c</code> 中查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">configEnum maxmemory_policy_enum[] = {</span><br><span class="line">    {<span class="string">"volatile-lru"</span>, MAXMEMORY_VOLATILE_LRU},</span><br><span class="line">    {<span class="string">"volatile-lfu"</span>, MAXMEMORY_VOLATILE_LFU},</span><br><span class="line">    {<span class="string">"volatile-random"</span>,MAXMEMORY_VOLATILE_RANDOM},</span><br><span class="line">    {<span class="string">"volatile-ttl"</span>,MAXMEMORY_VOLATILE_TTL},</span><br><span class="line">    {<span class="string">"allkeys-lru"</span>,MAXMEMORY_ALLKEYS_LRU},</span><br><span class="line">    {<span class="string">"allkeys-lfu"</span>,MAXMEMORY_ALLKEYS_LFU},</span><br><span class="line">    {<span class="string">"allkeys-random"</span>,MAXMEMORY_ALLKEYS_RANDOM},</span><br><span class="line">    {<span class="string">"noeviction"</span>,MAXMEMORY_NO_EVICTION},</span><br><span class="line">    {<span class="literal">NULL</span>, <span class="number">0</span>}</span><br><span class="line">};</span><br></pre></td></tr></table></figure>

<p>上述常量定义在 <code>server.h</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Redis maxmemory strategies. Instead of using just incremental number</span></span><br><span class="line"><span class="comment"> * for this defines, we use a set of flags so that testing for certain</span></span><br><span class="line"><span class="comment"> * properties common to multiple policies is faster. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_FLAG_LRU (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_FLAG_LFU (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_FLAG_ALLKEYS (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_FLAG_NO_SHARED_INTEGERS \</span></span><br><span class="line"><span class="meta">    (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_VOLATILE_LRU ((0&lt;&lt;8)|MAXMEMORY_FLAG_LRU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_VOLATILE_LFU ((1&lt;&lt;8)|MAXMEMORY_FLAG_LFU)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_VOLATILE_TTL (2&lt;&lt;8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_VOLATILE_RANDOM (3&lt;&lt;8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_ALLKEYS_LRU ((4&lt;&lt;8)|MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_ALLKEYS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_ALLKEYS_LFU ((5&lt;&lt;8)|MAXMEMORY_FLAG_LFU|MAXMEMORY_FLAG_ALLKEYS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_ALLKEYS_RANDOM ((6&lt;&lt;8)|MAXMEMORY_FLAG_ALLKEYS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEMORY_NO_EVICTION (7&lt;&lt;8)</span></span><br></pre></td></tr></table></figure>

<p>由自身经验或注释均可知，<code>Redis</code> 没有使用增量数字来定义这些常量，而是使用了一组标志，以便<strong>更快地测试多个策略的某些共同属性</strong>。在后续的代码分析中，我们会看到 <code>Redis</code> 是如何通过<strong>位运算</strong>判断内存淘汰策略是否具有某一属性，比如是否属于 <code>LRU</code> 类型就可以通过 <code>server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU</code> 来判断。</p>
<h2 id="Redis-的内存淘汰优化"><a href="#Redis-的内存淘汰优化" class="headerlink" title="Redis 的内存淘汰优化"></a>Redis 的内存淘汰优化</h2><p>和普通版本的 <code>LRU</code> 以及 <code>LFU</code> 算法实现并不完全相同，<code>Redis</code> 的 <code>LRU</code> 和 <code>LFU</code> 做了一些“优化”，<strong>主要目的是降低内存和时间的开销</strong>。</p>
<h3 id="近似-LRU"><a href="#近似-LRU" class="headerlink" title="近似 LRU"></a>近似 LRU</h3><blockquote>
<p>代码注释中使用了 approximated LRU algorithm 作为表述。</p>
</blockquote>
<p><code>Redis</code> 的 <code>LRU</code> 并非严格的 <code>LRU</code>，而是使用了“近似 <code>LRU</code>”。在具体实现中，<code>Redis</code> 为了节省内存，并没有维护一个完整的 <code>LRU</code> 链表，而是为每个 <code>key</code> 维护一个“<strong>最后访问时间</strong>”，然后通过采样机制检查一部分 <code>key</code>，在通过筛选获得的候选 <code>key</code> 中选出其中最近最少使用的 <code>key</code> 进行淘汰。</p>
<ul>
<li><strong>访问时间戳</strong>：<code>Redis</code> 为每个键维护一个“最后访问时间”，用于实现 <code>LRU</code>。</li>
<li><strong>采样机制</strong>：当已用内存超出 <code>maxmemory</code> 时，<code>Redis</code> 会通过采样机制获取一部分 <code>key</code> 加以筛选，然后在通过筛选获得的候选 <code>key</code> 中选取“最后访问时间”最久远的 <code>key</code> 进行淘汰。这个采样机制降低了内存的开销，也减少了计算的复杂度。</li>
<li><strong>采样精度</strong>：用户可以通过配置参数 <code>maxmemory-samples</code> 调整采样数量来影响采样的精度。采样数量越多，近似 <code>LRU</code> 越接近于真实的 <code>LRU</code>（回头再看这句陈述，个人并不能严谨的证明）。</li>
</ul>
<blockquote>
<p>事实上，<br>“最后访问时间”并不是简单地直接使用我们常用的时间戳，而是为了节省内存对时间戳做了点小处理。<br><code>Redis</code> 的采样机制也不是简单地在每次需要进行内存淘汰时获取一部分 <code>key</code>，然后从这部分 <code>key</code> 中选择要淘汰的目标。如果是这样，并不能选出更应该优先被淘汰的 <code>key</code>。<br>回头再看“采样数量越多，越接近于真实的 <code>LRU</code>”这句话，个人虽然予以保留，但心里是存疑的，个人只能确认增加采样的数量在一定程度上可以<strong>加快</strong>接近真实 LRU 的速度。</p>
</blockquote>
<h3 id="近似-LFU"><a href="#近似-LFU" class="headerlink" title="近似 LFU"></a>近似 LFU</h3><p><code>Redis</code> 的 <code>LFU</code> 同样并非严格的 <code>LFU</code>，也是使用了“近似 <code>LFU</code>”。<code>Redis</code> 在使用 <code>LFU</code> 策略时，会为每个 <code>key</code> 维护一个“频率计数器”，然后通过和 <code>LRU</code> 相同的采样机制，在通过筛选获得的候选 <code>key</code> 中选出其中最近最不常使用的 <code>key</code> 进行淘汰，若访问频率相同，则选择最近最少使用的 <code>key</code>。</p>
<ul>
<li><strong>计数器设计</strong>：<code>Redis</code> 为每个 <code>key</code> 维护一个 <code>8</code> 位的“频率计数器”，其取值范围是 <code>0-255</code>，用于统计访问频率。<strong>注意</strong>：这个“频率计数器”不直接记录访问次数，而是记录访问次数的对数 <code>logc</code>（logistic counter）。</li>
<li><strong>随时间衰减</strong>：<code>Redis</code> 的 <code>LFU</code> 还使用了频率衰减机制，以避免陈旧的高频 <code>key</code> 长期占据内存。在使用 <code>LFU</code> 策略时，<code>Redis</code> 不仅为每个 <code>key</code> 维护一个“频率计数器”，还会维护一个 <code>ldt</code>（last decrement time），用于记录上一次 <code>logc</code> 的更新时间。<code>Redis</code> 会根据当前的时间和 <code>ldt</code> 的差值以及配置的 <code>lfu-decay-time</code> 对 <code>logc</code> 进行衰减。</li>
<li><strong>衰减时间</strong>：用户可以通过配置项 <code>lfu-decay-time</code> 控制衰减的速率，默认是 <code>1</code>。</li>
<li><strong>采样精度</strong>：和 <code>LRU</code> 一样，用户可以通过配置参数 <code>maxmemory-samples</code> 调整采样数量来影响采样的精度。事实上 <code>LRU</code>、<code>LFU</code> 和 <code>TTL</code> 共用了同一个采样机制。</li>
</ul>
<blockquote>
<p>事实上，<code>logc</code> 并不是直接对访问次数求对数而得，因为求对数是一个较为复杂的操作。<code>Redis</code> 通过<strong>加权衰减</strong>机制模拟对数增长，在访问时它会根据 <code>logc</code> 的数值决定增加“频率计数器”的概率，公式可以简化为：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.016ex;" xmlns="http://www.w3.org/2000/svg" width="12.878ex" height="5.052ex" role="img" focusable="false" viewBox="0 -1342 5692 2233"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(780.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(1836.6,0)"><g data-mml-node="mn" transform="translate(1677.7,676)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(1260,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(1915.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2915.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><rect width="3615.4" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container><br>真正的公式有少许调整，我们会在后续代码分析中进一步探究。这个公式使得“频率计数器”的增长是非线性的——计数越高，增加的概率越小，从而避免计数器快速增长导致溢出。对于高频访问的 <code>key</code>，“频率计数器”仍能达到较高的值；对于低频访问的 <code>key</code>，“频率计数器”增长缓慢，在内存淘汰时也更容易被淘汰。</p>
</blockquote>
<blockquote>
<p>关于“随时间衰减”机制，其实个人在刚开始对具体细节就有些好奇，对一些不够清晰的表述也有些困惑，而探究的过程也确实“一波三折”。有些资料将其称为“定期衰减”，个人感觉有点容易让人误解，随意取了一个名字。</p>
</blockquote>
<h2 id="Redis-的内存淘汰实现细节"><a href="#Redis-的内存淘汰实现细节" class="headerlink" title="Redis 的内存淘汰实现细节"></a>Redis 的内存淘汰实现细节</h2><blockquote>
<p>在了解 <code>Redis</code> 内存淘汰算法的优化思路时，情不自禁会设想如何处理脑海中浮现的一些问题。有时候并不是不知道“看了源代码就知道了”，而是对不熟悉的项目可能不知道从何开始看，以至于“开始”成了最难的一个步骤。</p>
</blockquote>
<h3 id="freeMemoryIfNeeded"><a href="#freeMemoryIfNeeded" class="headerlink" title="freeMemoryIfNeeded"></a>freeMemoryIfNeeded</h3><p><code>Redis</code> 处理内存淘汰的过程是定义在 <code>evict.c</code> 中的 <code>freeMemoryIfNeeded</code> 方法，它会先判断是否真正需要进行内存淘汰，如果需要则根据设置的内存淘汰策略执行相应的操作。</p>
<ol>
<li>内存淘汰前判断和处理。<ol>
<li>比较已用内存和 <code>maxmemory</code> 判断是否需要进行内存淘汰（由此可见<strong>一些配置项会被转换为 <code>server</code> 的属性</strong>在代码中使用）。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">* to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">mem_reported = zmalloc_used_memory();</span><br><span class="line"><span class="keyword">if</span> (mem_reported &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br></pre></td></tr></table></figure></li>
<li>在真正淘汰 <code>key</code> 前会先尝试释放主从同步和 <code>AOF</code> 的缓冲区占用的内存（由此可见这部分的内存也被计算在已用内存中，也就是说已用内存<strong>不单单只包含存储数据占用的内存</strong>），如果在释放后内存已经够用，则直接返回。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment"> * count of used memory. */</span></span><br><span class="line">mem_used = mem_reported;</span><br><span class="line"><span class="type">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line"><span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br></pre></td></tr></table></figure></li>
<li>计算需要释放的内存（按这个计算方式，释放到 <code>maxmemory</code> 即可写入数据？那不是有机会在最后放入一个超大 <code>key</code> 从而使已用内存超过阈值很多？）。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">mem_freed = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>根据设置的内存淘汰策略，执行相应的操作。<ol>
<li>如果策略设置为 <code>noeviction</code>，则直接跳转到不能释放内存的处理逻辑。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">    <span class="keyword">goto</span> cant_free;</span><br></pre></td></tr></table></figure>
 在 <code>cant_free</code> 代码块中，如果异步释放内存的线程正在执行任务，则等待（<strong>对于 if 判断条件不理解</strong>）。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cant_free:</span><br><span class="line"><span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">* last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">* and wait... */</span></span><br><span class="line"><span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) {</span><br><span class="line">    <span class="keyword">if</span> (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;= mem_tofree)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    usleep(<span class="number">1000</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> C_ERR;</span><br></pre></td></tr></table></figure></li>
<li>否则，循环“选取“最佳”的淘汰目标 <code>key</code> 然后释放内存”直到释放的内存大于需要释放的内存。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (mem_freed &lt; mem_tofree) {</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
 在 <code>while</code> 循环的内部，主要分为两个步骤：<br> 1. 选取“最佳”的淘汰目标 <code>key</code><br> 2. 释放内存</li>
</ol>
</li>
</ol>
<h3 id="选取“最佳”的淘汰目标-key"><a href="#选取“最佳”的淘汰目标-key" class="headerlink" title="选取“最佳”的淘汰目标 key"></a>选取“最佳”的淘汰目标 key</h3><p>选取“最佳”的淘汰目标 <code>key</code> 的处理分为两种情形：</p>
<ol>
<li>在使用 <code>LRU</code>、<code>LFU</code> 和 <code>TTL</code> 策略时，需要通过采样机制</li>
<li>在使用 <code>Random</code> 策略时，则较为简单</li>
</ol>
<p>相关的分支判断代码如下，判断过程通过位运算提高效率：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">    server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="在使用-Random-策略时选择-key"><a href="#在使用-Random-策略时选择-key" class="headerlink" title="在使用 Random 策略时选择 key"></a>在使用 Random 策略时选择 key</h4><p><code>Redis</code> 在使用 <code>Random</code> 策略时选择 <code>key</code> 的过程较为简单，所以我们先看这部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment"> * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment"> * incrementally visit all DBs. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) {</span><br><span class="line">    j = (++next_db) % server.dbnum;</span><br><span class="line">    db = server.db+j;   <span class="comment">// 指针运算</span></span><br><span class="line">    dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">            db-&gt;dict : db-&gt;expires;</span><br><span class="line">    <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) {</span><br><span class="line">        de = dictGetRandomKey(dict);</span><br><span class="line">        bestkey = dictGetKey(de);</span><br><span class="line">        bestdbid = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Redis</code> 首先使用一个静态全局的变量 <code>next_db</code> 用于遍历所有 <code>DB</code>。</li>
<li>然后根据是否为 <code>allkeys</code> 类型的策略，选择不同的 <code>dict</code>。通过指针运算，选择 <code>DB</code> 和 <code>dict</code> 的代码显得很优雅。</li>
<li><code>dictGetRandomKey</code> 方法定义在 <code>dict.c</code> 中，顾名思义，用于从哈希表 <code>dict</code> 中获得一个随机的条目 <code>dictEntry</code>。</li>
</ol>
<blockquote>
<p><code>db-&gt;dict</code> 是主字典，存储了 <code>key-value</code>；<code>db-&gt;expires</code> 存储了 <code>key-expire_time</code>。</p>
</blockquote>
<p><code>dictGetRandomKey</code> 方法并不复杂，即使不了解“重哈希”的实现细节，也很容易理解，主要分为两个步骤：</p>
<ol>
<li>用随机数作为数组索引选择一个非空 <code>bucket</code>。</li>
<li>在选择到一个非空 <code>bucket</code> 后，就得到了存储在那的链表。遍历并计算链表的大小，并再次用一个随机数选择一个 <code>dictEntry</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">dictEntry *<span class="title function_">dictGetRandomKey</span><span class="params">(dict *d)</span></span><br><span class="line">{</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> h;</span><br><span class="line">    <span class="type">int</span> listlen, listele;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 dict 大小为 0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 1. 用随机数作为数组索引选择一个非空 bucket</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) {</span><br><span class="line">        <span class="comment">// 如果正在重哈希，需要用到 ht[0] 和 ht[1]</span></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">/* We are sure there are no elements in indexes from 0</span></span><br><span class="line"><span class="comment">             * to rehashidx-1 */</span></span><br><span class="line">            h = d-&gt;rehashidx + (random() % (d-&gt;ht[<span class="number">0</span>].size +</span><br><span class="line">                                            d-&gt;ht[<span class="number">1</span>].size -</span><br><span class="line">                                            d-&gt;rehashidx));</span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        } <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 正常情况，只需要用到 ht[0]</span></span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h];</span><br><span class="line">        } <span class="keyword">while</span>(he == <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在选择到一个非空 bucket 后，用随机数在链表上选择一个 dictEntry</span></span><br><span class="line">    <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></span><br><span class="line"><span class="comment">     * list and we need to get a random element from the list.</span></span><br><span class="line"><span class="comment">     * The only sane way to do so is counting the elements and</span></span><br><span class="line"><span class="comment">     * select a random index. */</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="keyword">while</span>(he) {</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    }</span><br><span class="line">    listele = random() % listlen;</span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><code>dictSize</code> 方法定义在 <code>dict.h</code> 中，可以快速获取 <code>dict</code> 的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ChatGPT</code> 的胡言乱语中曾提到 <code>Redis</code> 需要遍历所有的 <code>key</code> 进行统计才可以知道 <code>key</code> 的数量，因此在使用 <code>Random</code> 策略进行内存淘汰时需要注意效率问题。不知道这个说法的诞生是否是因为考虑到获取随机的一个 <code>key</code> 需要遍历链表统计数量，而如果链表过长，可能会影响性能。</p>
</blockquote>
<h4 id="在使用-LRU、LFU-和-TTL-策略时选择-key"><a href="#在使用-LRU、LFU-和-TTL-策略时选择-key" class="headerlink" title="在使用 LRU、LFU 和 TTL 策略时选择 key"></a>在使用 LRU、LFU 和 TTL 策略时选择 key</h4><ol>
<li>采样机制的核心是一个保存了“更应该优先被淘汰”的 <code>key</code> 的候选池 <code>pool</code>，默认大小为 <code>16</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> =</span> EvictionPoolLRU;</span><br></pre></td></tr></table></figure></li>
<li><code>Redis</code> 遍历每个非空 <code>DB</code>，从中获取一部分 <code>key</code> <strong>尝试</strong>填充到 <code>pool</code> 中。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment"> * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment"> * every DB. */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) {</span><br><span class="line">    db = server.db+i;</span><br><span class="line">    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">            db-&gt;dict : db-&gt;expires;</span><br><span class="line">    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 填充 pool</span></span><br><span class="line">        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">        total_keys += keys;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br></pre></td></tr></table></figure></li>
<li>填充后的 <code>pool</code> 中的 <code>key</code> 已经按“更不应该优先被淘汰”到“更应该优先被淘汰”的顺序排序，在 <code>pool</code> 中从“最优先被淘汰”开始选择，直到选择到一个存在的 <code>key</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line"><span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) {</span><br><span class="line">    <span class="comment">// 如果 key 不存在，跳过（pool 可能没有满）</span></span><br><span class="line">    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">    bestdbid = pool[k].dbid;</span><br><span class="line">    <span class="comment">// 根据策略的不同，从对应的 dict 中获取 dictEntry</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) {</span><br><span class="line">        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">            pool[k].key);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">            pool[k].key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">        sdsfree(pool[k].key);</span><br><span class="line">    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">     * a ghost and we need to try the next element. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) {</span><br><span class="line">        <span class="comment">// 如果 key 存在</span></span><br><span class="line">        bestkey = dictGetKey(de);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 如果 key 不存在，可能已经过期或删除了？</span></span><br><span class="line">        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
<li>若在 <code>pool</code> 中找不到可以淘汰的 <code>key</code>，会循环上述过程直到选到一个可以淘汰的 <code>key</code> 为止 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) {   </span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="填充-EvictionPoolLRU"><a href="#填充-EvictionPoolLRU" class="headerlink" title="填充 EvictionPoolLRU"></a>填充 EvictionPoolLRU</h4><p>填充 <code>EvictionPoolLRU</code>（<code>pool</code>） 的过程，就是所谓采样的过程，<code>LRU</code>、<code>LFU</code> 和 <code>TTL</code> 共享了这部分处理逻辑。之所以命名中携带了 <code>LRU</code>，是因为这部分代码原先就是为了处理 <code>LRU</code> 而写的。</p>
<blockquote>
<p><code>Redis</code> 的代码中也会留下这种不修正命名的历史代码呢。代码洁癖既有好的一面，也有不好的一面，得取舍。</p>
</blockquote>
<ol>
<li>首先通过 <code>dictGetSomeKeys</code> 获取（最多） <code>maxmemory_samples</code> 个 <code>key</code>，该方法并不保证返回指定个数的结果。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j, k, count;</span><br><span class="line">dictEntry *samples[server.maxmemory_samples];</span><br><span class="line">count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br></pre></td></tr></table></figure></li>
<li>循环处理实际获得的 <code>dictEntry</code>，将它们与之前留在 <code>pool</code> 中的 <code>key</code> 进行比较，留下更应该优先被淘汰的 <code>key</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) {</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol>
<li>获取 <code>key</code> 以及视情况从主字典获取 <code>value</code>。这是因为 <code>db.expires</code> 中存储的 <code>value</code> 是过期时间，在使用 <code>TTL</code> 类型的策略时，使用过期时间就足以实现算法；在使用非 <code>TTL</code> 策略时，需要用到主字典存储的 <code>value</code> 对象头中的 <code>lru</code> 字段。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> idle;</span><br><span class="line">sds key;</span><br><span class="line">robj *o;</span><br><span class="line">dictEntry *de;</span><br><span class="line"></span><br><span class="line">de = samples[j];</span><br><span class="line"><span class="comment">// 获取 key</span></span><br><span class="line">key = dictGetKey(de);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the dictionary we are sampling from is not the main</span></span><br><span class="line"><span class="comment"> * dictionary (but the expires one) we need to lookup the key</span></span><br><span class="line"><span class="comment"> * again in the key dictionary to obtain the value object. */</span></span><br><span class="line"><span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) {</span><br><span class="line">    <span class="comment">// 非 TTL 策略中，需要从主字典中获取 value</span></span><br><span class="line">    <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">    o = dictGetVal(de);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
<li>计算 <code>idle</code> 作为评估 <code>key</code> 是否应该优先被淘汰的“得分”，分数越高表示越应该优先被淘汰。之所以叫做 <code>idle</code>，也是因为这部分代码原先就是为了处理 <code>LRU</code> 而写的。<code>idle</code> 在使用不同的内存淘汰策略时有不同的计算方式。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calculate the idle time according to the policy. This is called</span></span><br><span class="line"><span class="comment"> * idle just because the code initially handled LRU, but is in fact</span></span><br><span class="line"><span class="comment"> * just a score where an higher score means better candidate. */</span></span><br><span class="line"><span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) {</span><br><span class="line">    <span class="comment">// LRU</span></span><br><span class="line">    idle = estimateObjectIdleTime(o);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) {</span><br><span class="line">    <span class="comment">/* When we use an LRU policy, we sort the keys by idle time</span></span><br><span class="line"><span class="comment">     * so that we expire keys starting from greater idle time.</span></span><br><span class="line"><span class="comment">     * However when the policy is an LFU one, we have a frequency</span></span><br><span class="line"><span class="comment">     * estimation, and we want to evict keys with lower frequency</span></span><br><span class="line"><span class="comment">     * first. So inside the pool we put objects using the inverted</span></span><br><span class="line"><span class="comment">     * frequency subtracting the actual frequency to the maximum</span></span><br><span class="line"><span class="comment">     * frequency of 255. */</span></span><br><span class="line">    <span class="comment">// LFU</span></span><br><span class="line">    idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) {</span><br><span class="line">    <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">    <span class="comment">// TTL</span></span><br><span class="line">    idle = ULLONG_MAX - (<span class="type">long</span>)dictGetVal(de);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
<li>将当前 <code>key</code> 的“得分”和 <code>pool</code> 中已存在的 <code>key</code> 的得分进行比较，判断它是否应该被放入 <code>pool</code> 中，如果需要则做些前置处理。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment"> * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment"> * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">       pool[k].key &amp;&amp;</span><br><span class="line">       pool[k].idle &lt; idle) k++;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">     * and there are no empty buckets. */</span></span><br><span class="line">    <span class="comment">// 如果 key 的得分低于 pool 中最差的 key，则跳过</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) {</span><br><span class="line">    <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">    <span class="comment">// 如果目标位置为空，无需前置处理</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">     * greater than the element to insert.  */</span></span><br><span class="line">    <span class="comment">// 如果目标位置位于中间</span></span><br><span class="line">    <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">         * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">        <span class="comment">// 如果还有空位置，则将剩余的 key 右移一个位置</span></span><br><span class="line">        sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">        memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">            <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">        pool[k].cached = cached;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">        <span class="comment">// 如果没有空位置，只需要淘汰掉最低分，将跳过的 key 左移一个位置</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">         * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">        sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">        <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">        memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">        pool[k].cached = cached;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li>
<li>将评估为更应该优先被淘汰的 <code>key</code> 放入 <code>pool</code> 的相应位置 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to reuse the cached SDS string allocated in the pool entry,</span></span><br><span class="line"><span class="comment"> * because allocating and deallocating this object is costly</span></span><br><span class="line"><span class="comment"> * (according to the profiler, not my fantasy. Remember:</span></span><br><span class="line"><span class="comment"> * premature optimizbla bla bla bla. */</span></span><br><span class="line"><span class="type">int</span> klen = sdslen(key);</span><br><span class="line"><span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) {</span><br><span class="line">    pool[k].key = sdsdup(key);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">    sdssetlen(pool[k].cached,klen);</span><br><span class="line">    pool[k].key = pool[k].cached;</span><br><span class="line">}</span><br><span class="line">pool[k].idle = idle;</span><br><span class="line">pool[k].dbid = dbid;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>总的来说，<code>Redis</code> 维护了一个保存了更应该优先被淘汰的 <code>key</code> 的 <code>pool</code>（类似于排行榜前 100），大小为 <code>16</code>；每次采样，从每个非空 <code>DB</code> 中获取最多 <code>maxmemory_samples</code> 个 <code>key</code>，根据当前使用的内存淘汰策略对其进行评估；将当前 <code>key</code> 的评估结果和原先留在 <code>pool</code> 中的 <code>key</code> 的进行比较，留下更应该优先被淘汰的 <code>key</code>；随着内存淘汰的不断进行，<code>pool</code> 中的 <code>key</code> 将越来越具有“代表性”。</p>
<blockquote>
<p><code>dictGetSomeKeys</code> 像裹脚布一样，跳过算了。。。</p>
</blockquote>
<h3 id="淘汰-key"><a href="#淘汰-key" class="headerlink" title="淘汰 key"></a>淘汰 key</h3><p>在选取到“最佳”的淘汰目标 <code>key</code> 后，释放内存。</p>
<blockquote>
<p>无话可说，主要是对于内存分配和释放的代码，个人也没深入阅读。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bestkey) {</span><br><span class="line">    <span class="comment">// 确定 DB</span></span><br><span class="line">    db = server.db+bestdbid;</span><br><span class="line">    robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">    propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">    <span class="comment">// 计算释放的内存</span></span><br><span class="line">    delta = (<span class="type">long</span> <span class="type">long</span>) zmalloc_used_memory();</span><br><span class="line">    latencyStartMonitor(eviction_latency);</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">        dbAsyncDelete(db,keyobj);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dbSyncDelete(db,keyobj);</span><br><span class="line">    latencyEndMonitor(eviction_latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">    latencyRemoveNestedEvent(latency,eviction_latency);</span><br><span class="line">    delta -= (<span class="type">long</span> <span class="type">long</span>) zmalloc_used_memory();</span><br><span class="line">    mem_freed += delta;</span><br><span class="line">    <span class="comment">// 统计淘汰的 key</span></span><br><span class="line">    server.stat_evictedkeys++;</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">        keyobj, db-&gt;id);</span><br><span class="line">    decrRefCount(keyobj);</span><br><span class="line">    keys_freed++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the memory to free starts to be big enough, we may</span></span><br><span class="line"><span class="comment">     * start spending so much time here that is impossible to</span></span><br><span class="line"><span class="comment">     * deliver data to the slaves fast enough, so we force the</span></span><br><span class="line"><span class="comment">     * transmission here inside the loop. */</span></span><br><span class="line">    <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normally our stop condition is the ability to release</span></span><br><span class="line"><span class="comment">     * a fixed, pre-computed amount of memory. However when we</span></span><br><span class="line"><span class="comment">     * are deleting objects in another thread, it's better to</span></span><br><span class="line"><span class="comment">     * check, from time to time, if we already reached our target</span></span><br><span class="line"><span class="comment">     * memory, since the "mem_freed" amount is computed only</span></span><br><span class="line"><span class="comment">     * across the dbAsyncDelete() call, while the thread can</span></span><br><span class="line"><span class="comment">     * release the memory all the time. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) {</span><br><span class="line">        overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">        mem_used = zmalloc_used_memory();</span><br><span class="line">        mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) {</span><br><span class="line">            mem_freed = mem_tofree;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!keys_freed) {</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h3 id="如何评估“更应该优先被淘汰”"><a href="#如何评估“更应该优先被淘汰”" class="headerlink" title="如何评估“更应该优先被淘汰”"></a>如何评估“更应该优先被淘汰”</h3><p>在这部分我们会介绍 <code>Redis</code> 具体如何评估一个 <code>key</code> 更应该优先被淘汰。</p>
<h4 id="Redis-的对象头"><a href="#Redis-的对象头" class="headerlink" title="Redis 的对象头"></a>Redis 的对象头</h4><p>我们先看 <code>Redis</code> 的对象头，对象头中存储了评估所需要的信息，对象头的定义在 <code>server.h</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">} robj;</span><br></pre></td></tr></table></figure>

<p><strong>重点关注</strong> <code>lru</code> 字段，该字段为 <code>24</code> 位，在使用 <code>LRU</code> 策略时，存储 <code>server.lruclock</code>；在使用 <code>LFU</code> 策略时，存储两个值，分别是 <code>ldt</code> 和 <code>logc</code>。</p>
<p>在每次访问 <code>key</code> 时，<code>Redis</code> 都会更新该字段，相关处理逻辑在 <code>db.c</code> 的 <code>lookupKey</code> 方法中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags, dictEntry **deref)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) {</span><br><span class="line">        <span class="comment">// 如果使用 LFU 策略，则调用 updateLFU 方法</span></span><br><span class="line">        updateLFU(val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 否则，将 lru 赋值为 LRU_CLOCK 的返回值</span></span><br><span class="line">        val-&gt;lru = LRU_CLOCK();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="在使用-LRU-策略时的评估机制"><a href="#在使用-LRU-策略时的评估机制" class="headerlink" title="在使用 LRU 策略时的评估机制"></a>在使用 LRU 策略时的评估机制</h4><p>在使用 <code>LRU</code> 策略时，每次访问 <code>key</code>，都会更新 <code>lru</code> 字段为 <code>LRU_CLOCK</code> 方法的返回值。如果 <code>Redis</code> 刷新 <code>lruclock</code> 的频率高于一定程度，则获取缓存的 <code>lru_clock</code>；否则获取系统时间计算 <code>lruclock</code>。</p>
<blockquote>
<p>由于这个分辨率（resolution）的概念有点抽象，感觉描述起来有点奇怪，但意会一下并不困难。我们可以先往下看看 <code>lruclock</code> 的定义和更新。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is used to obtain the current LRU clock.</span></span><br><span class="line"><span class="comment"> * If the current resolution is lower than the frequency we refresh the</span></span><br><span class="line"><span class="comment"> * LRU clock (as it should be in production servers) we return the</span></span><br><span class="line"><span class="comment"> * precomputed value, otherwise we need to resort to a system call. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">LRU_CLOCK</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) {</span><br><span class="line">        <span class="comment">// 获取缓存的 lruclock</span></span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 系统调用，获得当下的 lruclock</span></span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h5 id="lruclock-的定义和更新"><a href="#lruclock-的定义和更新" class="headerlink" title="lruclock 的定义和更新"></a>lruclock 的定义和更新</h5><p>在 <code>Redis</code> 中，<code>server.lruclock</code> 是用于 <code>LRU</code> 的时钟，我们通过它来计算 <code>key</code> 的空闲时间 <code>idle</code>。<code>lruclock</code> 并不直接使用时间戳，为了节省内存，它使用了秒级时间戳对常量 <code>LRU_CLOCK_MAX</code> 取余的结果，这样就可以只用 <code>24</code> 位存储。计算 <code>lruclock</code> 的方法 <code>getLRUClock</code> 定义在 <code>evict.c</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the LRU clock, based on the clock resolution. This is a time</span></span><br><span class="line"><span class="comment"> * in a reduced-bits format that can be used to set and check the</span></span><br><span class="line"><span class="comment"> * object-&gt;lru field of redisObject structures. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">getLRUClock</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>相关常量定义在 <code>server.h</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_CLOCK_MAX ((1<span class="string">&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;</span>lru */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>LRU_CLOCK_RESOLUTION</code> 表示时钟分辨率（感觉这个概念有点抽象，好像在不同代码中有多个概念重叠在里面了，不过大概明白它的用处）。</li>
<li>最大值 <code>LRU_CLOCK_MAX</code> 就是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.09ex" role="img" focusable="false" viewBox="0 -841.7 3012.6 923.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>。</li>
<li><code>lruclock</code> 是一个 <code>24</code> 位表示的整数，大约 <code>194</code> 天“清零”一次。</li>
</ul>
<p><code>server.lruclock</code> 是 <code>lruclock</code> 的缓存，会定期更新。相关处理逻辑在 <code>server.c</code> 的 <code>serverCron</code> 防范中，该方法中的操作每秒钟执行 <code>server.hz</code> 次，<code>server.hz</code> 的默认值为 <code>10</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    server.lruclock = getLRUClock();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之所以需要缓存 <code>lruclock</code> 是因为 <code>mstime</code> 方法是系统调用，消耗较高。也就是说在 <code>LRU</code> 时钟分辨率为 <code>1000ms</code> 时，只要每秒钟更新至少一次，我们就可以使用缓存的 <code>lruclock</code>。</p>
</blockquote>
<h5 id="空闲时间的计算"><a href="#空闲时间的计算" class="headerlink" title="空闲时间的计算"></a>空闲时间的计算</h5><p>计算 <code>key</code> 的空闲时间 <code>idle</code> 的方法 <code>estimateObjectIdleTime</code> 定义在 <code>evict.c</code> 中：</p>
<ol>
<li>获取 <code>lruclock</code></li>
<li>计算空闲时间 <code>idle</code>，考虑 <code>lruclock</code> 折返分两种情况</li>
</ol>
<blockquote>
<p>Redis 并没有考虑时钟多次折返的情况，它假设时钟折返发生的频率非常低，认为一次折返已经覆盖了大部分情况。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given an object returns the min number of milliseconds the object was never</span></span><br><span class="line"><span class="comment"> * requested, using an approximated LRU algorithm. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">estimateObjectIdleTime</span><span class="params">(robj *o)</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> lruclock = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) {</span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) *</span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h4 id="在使用-LFU-策略时的评估机制"><a href="#在使用-LFU-策略时的评估机制" class="headerlink" title="在使用 LFU 策略时的评估机制"></a>在使用 LFU 策略时的评估机制</h4><p>在使用 <code>LFU</code> 策略时，每次访问 <code>key</code>，都会调用 <code>updateLFU(val)</code> 更新 <code>lru</code> 字段，该字段保存了两个值，分别是 <code>ldt</code>（last decrement time，16 bit） 和 <code>logc</code>（logistic counter，8 bit）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Update LFU when an object is accessed.</span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateLFU</span><span class="params">(robj *val)</span> {</span><br><span class="line">    <span class="comment">// 计算衰减后的 logc</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    <span class="comment">// 根据计算得到的概率处理 logc 的自增</span></span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    <span class="comment">// 更新 lru 字段</span></span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h5 id="logc-的定义和更新"><a href="#logc-的定义和更新" class="headerlink" title="logc 的定义和更新"></a>logc 的定义和更新</h5><p>显然，<code>8 bit</code> 的 <code>logc</code> 虽然节省了内存空间，但是不足以存储真正的访问次数，在设计上它存储的是访问次数的对数，在实现上 <code>Redis</code> 通过“加权衰减”机制模拟了 <code>logc</code> 的对数增长。计算的方法定义在 <code>evict.c</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Logarithmically increment a counter. The greater is the current counter value</span></span><br><span class="line"><span class="comment"> * the less likely is that it gets really implemented. Saturate it at 255. */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LFULogIncr</span><span class="params">(<span class="type">uint8_t</span> counter)</span> {</span><br><span class="line">    <span class="comment">// 1. 以达到最大值则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 2. 计算一个随机概率值</span></span><br><span class="line">    <span class="type">double</span> r = (<span class="type">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="comment">// LFU_INIT_VAL 默认值是 5</span></span><br><span class="line">    <span class="type">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3. 计算增加计数器的概率，其中 lfu_log_factor 默认值是 10</span></span><br><span class="line">    <span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 4. 比较决定是否增加概率值</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>根据代码，我们可以知道，增加“频率计数器”的概率的计算公式如下：</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.747ex;" xmlns="http://www.w3.org/2000/svg" width="63.783ex" height="8.625ex" role="img" focusable="false" viewBox="0 -2156 28192.1 3812"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mo" transform="translate(780.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mrow" transform="translate(1836.6,0)"><g data-mml-node="mo"><path data-c="23A7" d="M712 899L718 893V876V865Q718 854 704 846Q627 793 577 710T510 525Q510 524 509 521Q505 493 504 349Q504 345 504 334Q504 277 504 240Q504 -2 503 -4Q502 -8 494 -9T444 -10Q392 -10 390 -9Q387 -8 386 -5Q384 5 384 230Q384 262 384 312T383 382Q383 481 392 535T434 656Q510 806 664 892L677 899H712Z" transform="translate(0,1257)"></path><path data-c="23A9" d="M718 -893L712 -899H677L666 -893Q542 -825 468 -714T385 -476Q384 -466 384 -282Q384 3 385 5L389 9Q392 10 444 10Q486 10 494 9T503 4Q504 2 504 -239V-310V-366Q504 -470 508 -513T530 -609Q546 -657 569 -698T617 -767T661 -812T699 -843T717 -856T718 -876V-893Z" transform="translate(0,-757)"></path><path data-c="23A8" d="M389 1159Q391 1160 455 1160Q496 1160 498 1159Q501 1158 502 1155Q504 1145 504 924Q504 691 503 682Q494 549 425 439T243 259L229 250L243 241Q349 175 421 66T503 -182Q504 -191 504 -424Q504 -600 504 -629T499 -659H498Q496 -660 444 -660T390 -659Q387 -658 386 -655Q384 -645 384 -425V-282Q384 -176 377 -116T342 10Q325 54 301 92T255 155T214 196T183 222T171 232Q170 233 170 250T171 268Q171 269 191 284T240 331T300 407T354 524T383 679Q384 691 384 925Q384 1152 385 1155L389 1159Z" transform="translate(0,0)"></path><svg width="889" height="287" y="1060" x="0" viewBox="0 50.6 889 287"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,1.412)"></path></svg><svg width="889" height="287" y="-847" x="0" viewBox="0 50.6 889 287"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,1.412)"></path></svg></g><g data-mml-node="mtable" transform="translate(889,0)"><g data-mml-node="mtr" transform="translate(0,1406)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mtd" transform="translate(13389.4,0)"><g data-mml-node="mtext"><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z"></path><path data-c="66" d="M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z" transform="translate(278,0)"></path><path data-c="A0" d="" transform="translate(584,0)"></path></g><g data-mml-node="mi" transform="translate(834,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1132,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1617,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(2094,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(2804.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3860.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path></g></g></g><g data-mml-node="mtr" transform="translate(0,206)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mtd" transform="translate(13389.4,0)"><g data-mml-node="mtext"><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z"></path><path data-c="66" d="M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z" transform="translate(278,0)"></path><path data-c="A0" d="" transform="translate(584,0)"></path></g><g data-mml-node="mi" transform="translate(834,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1132,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1617,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(2094,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(2804.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(3860.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(4158.6,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(4708.6,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5280.6,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(5780.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6125.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6725.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7070.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(7431.6,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(7931.6,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(8416.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(8945.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g></g></g><g data-mml-node="mtr" transform="translate(0,-1108.9)"><g data-mml-node="mtd"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(6017.9,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mrow" transform="translate(220,-370.3) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(687,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1172,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(1649,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(2082,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(2860,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(3158,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(3708,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4280,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(4780,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5125,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5725,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6070,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(6431,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(6931,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(7416,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(7945,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(8243,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8632,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(9132,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(9430,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(9980,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(10552,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(11052,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(11350,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(11835,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(12312,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(12812,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(13362,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(13891,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(14324,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(14685,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(15170,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(15621,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(16399,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><rect width="12149.4" height="60" x="120" y="220"></rect></g></g><g data-mml-node="mtd" transform="translate(13389.4,0)"><g data-mml-node="mtext"><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z"></path><path data-c="66" d="M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z" transform="translate(278,0)"></path><path data-c="A0" d="" transform="translate(584,0)"></path></g><g data-mml-node="mi" transform="translate(834,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1132,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(1682,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2254,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(2754,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3099,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3699,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4044,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(4405,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(4905,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(5390,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(5919,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(6494.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mi" transform="translate(7550.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(7848.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(8333.6,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(8810.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(9521.3,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mn" transform="translate(10577.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path></g></g></g></g><g data-mml-node="mo" transform="translate(26355.5,0) translate(0 250)"></g></g></g></g></svg></mjx-container></p>
<p>其中，<code>LFU_INIT_VAL</code> 是在使用 <code>LFU</code> 策略时用于初始化的默认值，默认为 <code>5</code>；<code>lfu_log_factor</code> 是 <code>LFU</code> 的频率计数器的对数增长系数，默认为 <code>10</code>。</p>
<h5 id="ldt-的定义和更新"><a href="#ldt-的定义和更新" class="headerlink" title="ldt 的定义和更新"></a>ldt 的定义和更新</h5><p><code>ldt</code> 的全称是 last decrement time，意思是 <code>logc</code> 最后衰减的时间。由于每次在访问时，都会进行衰减处理，因此 <code>ldt</code> 也具备“最后访问时间”的含义。</p>
<blockquote>
<p>在和 Chat GPT 吧啦吧啦的时候，对于衰减的时机一度产生了困惑，到底是访问时、定期的还是进行内存淘汰时？看代码到底是最靠谱的。</p>
</blockquote>
<p>但是和使用 <code>LRU</code> 策略时不同，由于存储 <code>ldt</code> 的位数只有 <code>16</code> 位，计算的方式变成以下这样，取分钟级时间戳对 <code>65535</code> 取余。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the current time in minutes, just taking the least significant</span></span><br><span class="line"><span class="comment"> * 16 bits. The returned time is suitable to be stored as LDT (last decrement</span></span><br><span class="line"><span class="comment"> * time) for the LFU implementation. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUGetTimeInMinutes</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>“随时间衰减”的处理逻辑定义在 <code>evict.c</code> 中的 <code>LFUDecrAndReturn</code> 方法，它会根据当前时间和 <code>ldt</code> 的差值以及配置项 <code>server.lfu_decay_time</code> 决定是否对 <code>logc</code> 进行衰减计算，然后返回最终的结果。<code>server.lfu_decay_time</code> 的含义是每个 <code>n</code> 分钟衰减 <code>1</code> 吗？Chat GPT 又迷惑到我了。当取值为 <code>0</code> 时不衰减。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUDecrAndReturn</span><span class="params">(robj *o)</span> {</span><br><span class="line">    <span class="comment">// 获取 ldt 和 counter</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 计算衰减周期数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>计算过去了多长时间，以分钟为单位，最多考虑一次时钟折返。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given an object last access time, compute the minimum number of minutes</span></span><br><span class="line"><span class="comment"> * that elapsed since the last access. Handle overflow (ldt greater than</span></span><br><span class="line"><span class="comment"> * the current 16 bits minutes time) considering the time as wrapping</span></span><br><span class="line"><span class="comment"> * exactly once. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">LFUTimeElapsed</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> ldt)</span> {</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<h5 id="不常访问程度的计算"><a href="#不常访问程度的计算" class="headerlink" title="不常访问程度的计算"></a>不常访问程度的计算</h5><p>在使用 <code>LFU</code> 策略中，不常访问程度（尽管变量名仍为 <code>idle</code>）的计算方式如下。注意：在内存淘汰时，尽管计算了衰减后的 <code>logc</code>，但是并未更新 <code>lru</code> 字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br></pre></td></tr></table></figure>

<h4 id="在使用-TTL-策略时的评估机制"><a href="#在使用-TTL-策略时的评估机制" class="headerlink" title="在使用 TTL 策略时的评估机制"></a>在使用 TTL 策略时的评估机制</h4><p>在使用 <code>TTL</code> 策略时，计算距离过期远近程度的计算方式如下，只需要 <code>db-&gt;expires</code> 中存储的过期时间，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idle = ULLONG_MAX - (<span class="type">long</span>)dictGetVal(de);</span><br></pre></td></tr></table></figure>

<h2 id="总结和感受"><a href="#总结和感受" class="headerlink" title="总结和感受"></a>总结和感受</h2><p>常见的内存淘汰算法并不难记忆和理解，<code>Redis</code> 的优化思路也并不复杂，但是我们难免会对黑盒中的一些细节产生好奇心，又会因为网上一些简化且不太准确的信息而产生困扰。这些问题，有时候如同鸡肋食之无味又弃之可惜，不探索无伤大雅但想起来又如鲠在喉，但是查看并理解相应源代码后豁然开朗的感受却是非常真实的。<br>深入探究 <code>Redis</code> 内存淘汰的具体实现，既可以帮助我们了解一个工业界成熟的内存淘汰算法实现方案是如何的，也可以了解到一些资料中一笔带过的信息背后的细节。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
              <a href="/tags/memory-eviction/" rel="tag"># memory eviction</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/26/memory-eviction-algorithms/" rel="prev" title="内存淘汰算法">
                  <i class="fa fa-angle-left"></i> 内存淘汰算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/12/10/how-to-add-a-friends-links-page-non-invasively-when-using-Hexo-NexT-theme/" rel="next" title="在使用 Hexo NexT 主题时如何无侵入式地添加友链页面">
                  在使用 Hexo NexT 主题时如何无侵入式地添加友链页面 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Moralok</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">150k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:20</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"3EC6DlIt15eVYStwSVsDsQ2P-MdYXbMMI","app_key":"KKBQicvLunsmAfgH3DJJXvng","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
